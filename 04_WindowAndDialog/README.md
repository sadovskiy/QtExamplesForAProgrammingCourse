# 04 Пример организации работы с окнами в Qt

Демонстрация работы приложения с GUI состоящего из объектов, расположенных на форме `MainWindow`:
- от класса `QPushButton`
- от класса `QGroupBox`
- от класса `QCheckBox`
- от класса `QLabel`
- от класса `QSpinBox`
- от класса `QStatusBar`


В данном приложении показано как можно взаимодействовать с окнами, созданными из собственных классов. Классы могут создаётся на основе формы в двух вариантах:
- на основе класса `DialogWindow` унаследованного от `QDialog`;
- на основе класса `FormWindow` унаследованного от `QWidget`.

В пример также показана работа с разными продолжительностями хранения в памяти для этих окон: автоматической и динамической.

Задавать настройки **"Delete on Close"** и **"Modal"** надо до создания окна. Само окно можно сделать через нажатия на кнопку **"New QWidget"** неограниченное количество раз, в обоих группах **"Dynamic Window"**.

Содержимое полей `QLineEdit` дочерних окно выводится с низу окна через объект класса `QStatusBar`.

## Окна с автоматической продолжительностью хранения
Окна `autoGlobWindow` и `dialog` созданы на основе классов `FormWindow` и `DialogWindow` соответственно с автоматической продолжительностью хранения. Однако окно `autoGlobWindow` имеет область видимости класса `MainWindow`, а окно `dialog` локальную область в теле метода `MainWindow::on_buttonDialogWindowA_clicked()`. Окнам образованным от класса `QWidget`, в отличии от `QDialog`, надо выставлять флаг отдельного окна методом `setWindowFlag(Qt::Window)`, иначе оно будет создано в родительском окне. Окно `dialog` после запуска перехватывает управление, так как является модальным окном. Модальное окно — это окно, которое блокирует родительское и другие окна приложения. Размещение этого окна как локального объекта, а так же вызов метода `exec()`, не дадут этому окну возможность взаимодействовать с пользователем в другом режиме. У окна `autoGlobWindow` нет метода `exec()`, но за счёт его размещения как члена класса, его можно использовать в любом методе, этого класса. В этом случае окно присутствует всегда, но его можно скрывать методом `hide()` (по умолчанию), а можно показать методом `show()`. Окна, образованные от класса `QWidget` не могут быть модальными.

В примере окно `dialog` позволяет ввести строку текста, которая хранится в этом окне как закрытая переменна `mStr`, член класса `DialogWindow`. После нажатия кнопки **ОК**, пока окно не
удалилось из памяти, эту строку можно извлечь через вызов метода `string()`. Другим способом является доступ непосредственно к полю ввода через вызов метода `data()`.

Окно `autoGlobWindow` содержит два поля ввода, которые надо передать во внешнюю программу одновременно. Для этого рационально использовать структуру `UserData`. В переменную `currentData` от этой структуры упаковываются нужные наборы данных, которые можно удобно передать в другое окно (объект) используя так называемые "геттеры" и "сеттеры". Иногда данные надо передать прям во время работы метода, тогда можно использовать специальный механизм сигнал/слот, описанный в предыдущем примере "SignalSlot". В данном примере используется сигнал `void valueChanged(FormWindow::UserData &ud)`, которые испускается когда пользователь нажимает кнопку **OK**.

## Окна с динамической продолжительностью хранения
В примере рассмотрены два окна образованные от класса `FormWindow`, но это не мешает использовать эту продолжительность хранения и для окон, образованных от класса `DialogWindow`.

Основной проблемой при использовании динамической продолжительности хранения окон и других объектов, является их удаление после того, как они перестали быть нужны. В **Qt** существует три способа контролировать динамические окна (объекты).
1. Использовать атрибут `Qt::WA_DeleteOnClose`;
2. Использовать сигнал `QObject::destroyed`;
3. Использовать класс `QPointer`.

Для демонстрации работы этих механизмов на форме главного окна созданы два `QGroupBox`. Использовать атрибут `Qt::WA_DeleteOnClose` можно в обоих случаях. Для этого надо поставить отметку в пункте **"Delete on Close"** на форме `MainWindow` соответствующего `QGroupBox`. В этом случае окно будет удалятся сразу после закрытия.

Ещё одна проблема заключается в том, что указатель в C++ после удаления динамического объекта не обнуляется и может указывать на уже несуществующие данные.

При использовании второго подхода надо сделать указатель типа `FormWindow`, который бы ссылался на динамический объект и связать его сигнал `QObject::destroyed` с методом, который обнулял бы этот указатель. В примере это решено за счёт использования анонимной лямбда-функции. Обнулить указатель нужно так `dynamicWndowD = nullptr`.

В третьем подходе используется класс `QPointer`, куда можно добавлять окна типа `FormWindow` при их создании. За счёт наличия метода `isNull()` можно проверить существует ли окно и удалить его `delete dynamicWndowP.data();`, а затем очистить сам указатель `dynamicWndowP`.

