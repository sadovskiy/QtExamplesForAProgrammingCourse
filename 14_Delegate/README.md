# 14 Пример реализации компонента отображения и редактирования данных в таблице Qt

Демонстрация работы приложения с GUI состоящего из объекта `tableWidget` от класса `QTableWidget`, расположенных на форме `MainWindow`.

В данном примере показано как можно создать специальные объекты отображения и редактирования ячеек таблицы. Для демонстрации в таблице создано четыре столбца. В первом имеется шкала выполнения, но если ячейку перевести в режим ввода, то появится поле ввода числовых данных. Второй столбец работает и отображает элементы типа `QCheckBox` работающие с бинарными данными. Третий демонстрирует работу с выпадающим списком, где пользователь должен выбрать один из предложенных вариантов. Четвёртый столбец, это обычная строка. Идея использования делегатов заключается в ограничении ввода пользователя, для обеспечения корректности и исключения мусорных данных. Например, если хранимые данные подразумевают, что значение должно быть бинарным, то логично пользователю отобразить для просмотра и редактирования в виде флажкового элемента (отражающего состояние). Это лучше сделать на основе объекта, созданного от класса `QCheckBox`. Или другой пример, вводимые значения должны быть ограничены определённым набором, из которого пользователю надо выбрать один из вариантов. Такой элемент интерфейса лучше реализовать на основе класса `QComboBox`. На самом деле выбор из элементов отображения и редактирования практический ничем не ограничен. По умолчанию всегда применяет элемент на основе класса `QLineEdit`. В самом руководстве **Qt** по технологии [модель преставление](https://doc.qt.io/qt-5/modelview.html#3-4-delegates), есть пример, где в роли элемента интерфейса сделаны [пять звёзд](https://doc.qt.io/qt-5/qtwidgets-itemviews-stardelegate-example.html). В этом примере представлен три самые ходовые варианты: `QCheckBox`, `QComboBox` и `QSpinBox`. Для работы с ними сделана форма главного окна с таблицей `ui->tableWidget` куда происходит прикрепление этих компонентов. Это делается в конструкторе с помощью метода `setItemDelegateForColumn()`, куда вставляется делегат, созданный в динамической памяти. Но, прежде чем им воспользоваться, надо сделать в отдельном файле делегат, который будет отвечать за работу с объектом основанном на одном из трёх наших классов. Все классы делегаты наследуются от абстрактного базового класса `QStyledItemDelegate` и в них должен быть реализован ряд обязательных методов:
1. `createEditor()` — метод создающий элемент интерфейса для работы с ячейкой.
2. `setEditorData()` — метод передающий значение из ячейки в созданный в предыдущем методе объект.
3. `setModelData()` — метод передающий значение из объекта в ячейку.
4. `updateEditorGeometry()` — метод рисующий новый объект в нужной ячейке.

Необязательных методов по обработке данных и работе с ячейками достаточно много. Подробнее следует изучать документацию.



Из особенностей работы можно ещё отметить необходимость в некоторых методах использование приведения типа **qobject_cast**. Это сделано для поиска и доступа к нужному элементу. Суть в том, что через указатель **editor** приходят разные объекты и надо среди них отсеять объект нашего типа, в чём и помогает **qobject_cast**.

В коде есть макрос `Q_UNUSED()`, он используется для обирания сообщений компилятора, о не используемой переменной.
