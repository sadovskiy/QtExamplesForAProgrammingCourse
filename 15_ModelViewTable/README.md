# 15 Пример реализации технологии модель/представление при работе с таблицей в Qt

Демонстрация работы приложения с GUI состоящего из основного объекта `tableView` от класса `QTableView` и других объектов, расположенных на форме `MainWindow`.

В данном примере показано как можно организовать логику программы используя подход модель/представление. На главном окне присутствует таблица, на которой выводятся данные в три столбца. Первый и второй столбец отображают простую строку текста типа `QString`, а третий показывает текущее время. Если ячейку в первом столбце очистить от текста, то она закрасится красным цветом, а если во втором столбце сделать также, то в зелёный. Время в третьем столбце убрать нельзя, а при каждой попытке его редактирования, оно будет обновляться. Под таблицей представлена строка и кнопка **Add String**. Если в строку ввести текст и нажать на кнопку, то строка будет вставлена в первый столбец, а во второй будет добавлено слово константа "new". Эта константа прописана в методе `TableModel::insertValue(const QString &value)`. В общем идея этого примера заключается в разделении класса управляющего данными от класса, отображающего данные, за счёт чего достигается большая гибкость в работе приложения. Сами данные хранятся в контейнерах `listStrA` и `listStrB`, которые находятся в модели `tableModel`. Класс `TableModel` создаётся на основе абстрактного класса по работе с таблицами `QAbstractTableModel`. Так для работы модели надо в обязательном порядке создать несколько методов таких как:
1. метод `rowCount()` — возвращает количество строк модели отображения данных. В нашем случае это объект `ui->tableView`.
2. метод `columnCount()` — возвращает количество столбцов.
3. метод `data()` — возвращает данные при отображении ячейки таблицы.
4. метод `setData()` — вставляет данные из делегата в контейнер при редактировании ячейки.
5. метод `flags()` — задаёт правила работы ячейки таблицы.


В примере из-за наличия двух столбцов используются два независимых списка `listStrA` и `listStrB`. В реальных приложения такая конструкция неудобна и редко используется. Обычно данные хранятся в одном контейнере в виде единого объекта, внутри которого находятся нужные сочетания данных. Заполняются эти контейнеры в конструкторе класса `TableModel` простым накручиванием через цикл.

В методе `TableModel::data(const QModelIndex &index, int role)` есть пара аргументов, `index` и `role`. `index` — это ячейка в представлении `ui->tableModel`, а `role` — это в каком качестве был вызван метод. Например, `Qt::DisplayRole`, `Qt::EditRole`, `Qt::BackgroundRole` и т.д. Полный список есть в [pдокументации](https://doc.qt.io/qt-5/qt.html#ItemDataRole-enum). Дело в том, что отображение ячейки это не только вывести текст, но правила отрисовки её, а сам метод `data()` даже для отображения одной ячейки, вызывается несколько раз. Эти вызовы как раз приходятся на разные роли, но за счёт использования оператора выбора `switch ()`, большинство из этих вызовов просто возвращают пустой `QVariant()` и ничего не происходит.


